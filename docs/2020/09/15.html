<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>15、bem css命名规范 |  前端小喵</title>
    <meta name="generator" content="VuePress 1.5.4">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="前端小喵微信公众号文章项目">
    <link rel="preload" href="/assets/css/0.styles.de540e03.css" as="style"><link rel="preload" href="/assets/js/app.617b9cc5.js" as="script"><link rel="preload" href="/assets/js/2.e6a2dc2d.js" as="script"><link rel="preload" href="/assets/js/7.9fa2cd7c.js" as="script"><link rel="prefetch" href="/assets/js/10.581b745b.js"><link rel="prefetch" href="/assets/js/11.40b22ce3.js"><link rel="prefetch" href="/assets/js/12.f43cf7fc.js"><link rel="prefetch" href="/assets/js/13.63ebe8b2.js"><link rel="prefetch" href="/assets/js/14.61b2e0d9.js"><link rel="prefetch" href="/assets/js/15.db8383cc.js"><link rel="prefetch" href="/assets/js/16.c66a6f5a.js"><link rel="prefetch" href="/assets/js/17.4a43ce9a.js"><link rel="prefetch" href="/assets/js/18.359f3686.js"><link rel="prefetch" href="/assets/js/19.ff1188d2.js"><link rel="prefetch" href="/assets/js/20.0ca6ba22.js"><link rel="prefetch" href="/assets/js/21.8e7215a1.js"><link rel="prefetch" href="/assets/js/22.d9181e53.js"><link rel="prefetch" href="/assets/js/23.640322f2.js"><link rel="prefetch" href="/assets/js/24.697e6c10.js"><link rel="prefetch" href="/assets/js/25.2ce8c5b5.js"><link rel="prefetch" href="/assets/js/26.392ffc11.js"><link rel="prefetch" href="/assets/js/27.655295cb.js"><link rel="prefetch" href="/assets/js/28.0558477a.js"><link rel="prefetch" href="/assets/js/29.bf421f0c.js"><link rel="prefetch" href="/assets/js/3.824e2a13.js"><link rel="prefetch" href="/assets/js/30.618e115b.js"><link rel="prefetch" href="/assets/js/31.53d6cb81.js"><link rel="prefetch" href="/assets/js/32.3cbeba60.js"><link rel="prefetch" href="/assets/js/33.979d1d9a.js"><link rel="prefetch" href="/assets/js/34.c45827a1.js"><link rel="prefetch" href="/assets/js/35.1e847f3c.js"><link rel="prefetch" href="/assets/js/4.5ed19beb.js"><link rel="prefetch" href="/assets/js/5.25e1e9fa.js"><link rel="prefetch" href="/assets/js/6.ebf1154f.js"><link rel="prefetch" href="/assets/js/8.d879a9fd.js"><link rel="prefetch" href="/assets/js/9.ba70e4e9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.de540e03.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/logo.jpg" alt=" 前端小喵" class="logo"> <span class="site-name can-hide"> 前端小喵</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/emoji/" class="nav-link">
  表情
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/resources/" class="nav-link">
  公众号编辑工具
</a></li><li class="dropdown-item"><!----> <a href="/images/noCopyright/" class="nav-link">
  无版权图片
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/emoji/" class="nav-link">
  表情
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Language Menu" class="dropdown-title"><span class="title">资源</span> <span class="arrow down"></span></button> <button type="button" aria-label="Language Menu" class="mobile-dropdown-title"><span class="title">资源</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/resources/" class="nav-link">
  公众号编辑工具
</a></li><li class="dropdown-item"><!----> <a href="/images/noCopyright/" class="nav-link">
  无版权图片
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">微信公众号文章首页</a></li><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>本地图片资源</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/images/noCopyright.html" class="sidebar-link">无版权图片网站</a></li><li><a href="/images/guanzhu.html" class="sidebar-link">求关注</a></li><li><a href="/images/line.html" class="sidebar-link">分割线</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><a href="/" class="sidebar-heading clickable router-link-active open"><span>2020年09月文章</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/2020/09/13.html" class="sidebar-link">13、经常要用到的但又总是记不住的样式</a></li><li><a href="/2020/09/14.html" class="sidebar-link">14、js常用数组的方法总结</a></li><li><a href="/2020/09/15.html" aria-current="page" class="active sidebar-link">15、bem css命名规范</a></li><li><a href="/2020/09/16.html" class="sidebar-link">16、javascript 中的 call 和 apply 实现原理</a></li><li><a href="/2020/09/17.html" class="sidebar-link">17、javascript 深拷贝和浅拷贝之如何对一个对象进行深度clone</a></li><li><a href="/2020/09/18.html" class="sidebar-link">18、小程序rich-text组件改变内部img图片样式的方法</a></li><li><a href="/2020/09/19.html" class="sidebar-link">19、前端SEO优化</a></li><li><a href="/2020/09/20.html" class="sidebar-link">20、 css常用和常用却容易忘记的样式合集</a></li><li><a href="/2020/09/21.html" class="sidebar-link">21、CSS阴影效果(Box-shadow)用法趣味讲解</a></li><li><a href="/2020/09/22.html" class="sidebar-link">22、 记住这几个git命令，创建、查看、删除、重命名和tag就够了～</a></li><li><a href="/2020/09/23.html" class="sidebar-link">23、一文搞懂this指向问题</a></li><li><a href="/2020/09/24.html" class="sidebar-link">24、数据响应式原理剖析</a></li><li><a href="/2020/09/25.html" class="sidebar-link">25、请编写一个 JavaScript 函数 parseQueryString，它的用途是把 URL 参数解析为一个对象</a></li><li><a href="/2020/09/26.html" class="sidebar-link">26、call 和 apply 的区别</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/" class="sidebar-heading clickable router-link-active"><span>2020年10月文章</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/2020/10/10.html" class="sidebar-link">koa-jsonp-demo</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="_15、bem-css命名规范"><a href="#_15、bem-css命名规范" class="header-anchor">#</a> 15、bem css命名规范</h1> <h4 id="css命名规范-bembem解决的问题"><a href="#css命名规范-bembem解决的问题" class="header-anchor">#</a> CSS命名规范-BEMBEM解决的问题</h4> <p>css的样式应用是全局性的，没有作用域可言。考虑以下场景</p> <h6 id="场景一-开发一个弹窗组件-在现有页面中测试都没问题-一段时间后-新需求新页面-该页面一打开这个弹窗组件-页面中样式都变样了-一查问题-原来是弹窗组件和该页面的样式相互覆盖了-接下来就是修改覆盖样式的选择器-又一段时间-又开发新页面-每次为元素命名都心惊胆战-求神拜佛-没写一条样式-f5都按多几次-每个组件都测试一遍"><a href="#场景一-开发一个弹窗组件-在现有页面中测试都没问题-一段时间后-新需求新页面-该页面一打开这个弹窗组件-页面中样式都变样了-一查问题-原来是弹窗组件和该页面的样式相互覆盖了-接下来就是修改覆盖样式的选择器-又一段时间-又开发新页面-每次为元素命名都心惊胆战-求神拜佛-没写一条样式-f5都按多几次-每个组件都测试一遍" class="header-anchor">#</a> 场景一：开发一个弹窗组件，在现有页面中测试都没问题，一段时间后，新需求新页面，该页面一打开这个弹窗组件，页面中样式都变样了，一查问题，原来是弹窗组件和该页面的样式相互覆盖了，接下来就是修改覆盖样式的选择器...又一段时间，又开发新页面，每次为元素命名都心惊胆战，求神拜佛，没写一条样式，F5都按多几次，每个组件都测试一遍...</h6> <h6 id="场景二-承接上文-由于页面和弹窗样式冲突了-所以把页面的冲突样式的选择器加上一些结构逻辑-比如子选择器、标签选择器-借此让选择器独一无二。一段时间后-新同事接手跟进需求-对样式进行修改-由于选择器是一连串的结构逻辑-看不过来-嫌麻烦-就干脆在样式文件最后用另一套选择器-加上了覆盖样式-接下来又有新的需求-最后的结果-一个元素对应多套样式-遍布整个样式文件"><a href="#场景二-承接上文-由于页面和弹窗样式冲突了-所以把页面的冲突样式的选择器加上一些结构逻辑-比如子选择器、标签选择器-借此让选择器独一无二。一段时间后-新同事接手跟进需求-对样式进行修改-由于选择器是一连串的结构逻辑-看不过来-嫌麻烦-就干脆在样式文件最后用另一套选择器-加上了覆盖样式-接下来又有新的需求-最后的结果-一个元素对应多套样式-遍布整个样式文件" class="header-anchor">#</a> 场景二：承接上文，由于页面和弹窗样式冲突了，所以把页面的冲突样式的选择器加上一些结构逻辑，比如子选择器、标签选择器，借此让选择器独一无二。一段时间后，新同事接手跟进需求，对样式进行修改，由于选择器是一连串的结构逻辑，看不过来，嫌麻烦，就干脆在样式文件最后用另一套选择器，加上了覆盖样式...接下来又有新的需求...最后的结果，一个元素对应多套样式，遍布整个样式文件...</h6> <p>以往开发组件，我们都用“重名概率小”或者干脆起个“当时认为是独一无二的名字”来保证样式不冲突，这是不可靠的。</p> <p>理想的状态下，我们开发一套组件的过程中，我们应该可以随意的为其中元素进行命名，而不必担心它是否与组件以外的样式发生冲突。</p> <p>BEM解决这一问题的思路在于，由于项目开发中，每个组件都是唯一无二的，其名字也是独一无二的，组件内部元素的名字都加上组件名，并用元素的名字作为选择器，自然组件内的样式就不会与组件外的样式冲突了。</p> <p>这是通过组件名的唯一性来保证选择器的唯一性，从而保证样式不会污染到组件外。</p> <p>这也可以看作是一种“硬性约束”，因为一般来说，我们的组件会放置在同一目录下，那么操作系统中，同一目录下文件名必须唯一，这一点也就确保了组件之间不会冲突。
BEM的命名规矩很容易记：<code>block-name__element-name--modifier-name</code>，也就是<code>模块名 + 元素名 + 修饰器名</code>。</p> <p>一般来说，根据组件目录名来作为组件名字：</p> <p>比如分页组件：
<code>/app/components/page-btn/</code>
那么该组件模块就名为<code>page-btn</code>，组件内部的元素命名都必须加上模块名，比如：</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;div class=&quot;page-btn&quot;]]&gt; 
    &amp;lt;button type=&quot;button&quot; class=&quot;page-btn__prev&quot;]]&gt;上一页&amp;lt;/button]]&gt; 
    &amp;lt;!-- ... --&amp;gt; 
    &amp;lt;button type=&quot;button&quot; class=&quot;page-btn__next&quot;]]&gt;下一页&amp;lt;/button]]&gt; &amp;lt;/div]]&gt;
</code></pre></div><p>上面我们用双下划线来明确区分模块名和元素名，当然也可以用单下划线，比如<code>page-btn_prev</code>和<code>page-btn_next</code>。我们只需保留BEM的思想，其命名规范可以任意变通。</p> <p>一开始了解BEM的时候，可能会产生误解，出现以下不正确的命名方式：</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;div class=&quot;page-btn&quot;]]&gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;ul class=&quot;page-btn__list&quot;]]&gt; &amp;lt;li class=&quot;page-btn__list__item&quot;]]&gt; &amp;lt;a href=&quot;#&quot; class=&quot;page-btn__list__item__link&quot;]]&gt;第一页&amp;lt;/a]]&gt; &amp;lt;/li]]&gt; &amp;lt;/ul]]&gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/div]]&gt;
</code></pre></div><p>分页组件有个ul列表名为：<code>page-btn__list</code>，列表里面存放每一页的按钮，名为：<code>page-btn__list__item__link</code>，这是不对的。
首先，有悖BEM命名规范，BEM的命名中只包含三个部分，元素名只占其中一部分，所以不能出现多个元素名的情况，所以上述每一页的按钮名可以改成： <code>page-btn__btn</code>  。</p> <p>其次，有悖BEM思想，BEM是不考虑结构的，比如上面的分页按钮，即使它是在ul列表里面，它的命名也不应该考虑其父级元素。当我们遵循了这个规定，无论父元素名发生改变，或是模块构造发生的改变，还是元素之间层级关系互相变动，这些都不会影响元素的名字。</p> <p>所以即使需求变动了，分页组件该有按钮还是要有按钮的，DOM构造发生变动，至多也就不同元素的增删减，模块内名称也随之增删减，而不会出现修改名字的情况，也就不会因为名字变动，牵涉到JS文件的修改，或样式文件的修改。</p> <h6 id="bem命名好长"><a href="#bem命名好长" class="header-anchor">#</a> BEM命名好长</h6> <p>BEM的命名中包含了模块名，长长的命名会让HTML标签会显得臃肿。</p> <p>其实每个使用BEM的开发团队多多少少会改变其命名规范，比如Instagram团队使用的驼峰式:</p> <div class="language- extra-class"><pre class="language-text"><code>.blockName-elementName--modifierName { /* ... */ } 还有单下划线：
.block-name_element-name--modifierName { /* ... */ } 还有修饰器名用单横线连接：
.blockName__elementName-modifierName { /* ... */ } 
</code></pre></div><p>其实这些对缩短命名没有多大的帮助，但我们也无需担心文件体积的问题，由于服务端有gzip压缩，BEM命名相同的部分多，压缩下来的体积不会太大。另外现在都用IDE来编写代码了，有自动提示功能，也无须担心重复的输入过长的名字。</p> <p>因为命名长，我们是不是可以用子代选择器来代替BEM命名？这样至少在HTML编写时，让HTML标签看起来美观一点。</p> <p>下面说说子代选择器带来的问题。</p> <h5 id="子选择器"><a href="#子选择器" class="header-anchor">#</a> 子选择器</h5> <p>子代选择器的方式是，通过组件的根节点的名称来选取子代元素。按照这个思路，分页按钮样式可以这么写：</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;div class=&quot;page-btn&quot;]]&gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;ul class=&quot;list&quot;]]&gt;&amp;lt;/ul]]&gt; &amp;lt;!-- ... --&amp;gt; &amp;lt;/div]]&gt; .page-btn { /* ... */ } .page-btn .list { /* ... */ }
</code></pre></div><p>HTML看起来美观多了，但这解决了样式冲突问题么？试想下，如果让你来接手这个项目，要增加一个需求，新增一个组件，你命名放心么？</p> <h6 id="你面临的问题是-你打开组件目录-里面有个分页组件-叫做page-btn-可是你完全不知道要怎么给新组件命名-因为即使新组件模块名与page-btn不一样-也不能保证新组件与分页组件不冲突。"><a href="#你面临的问题是-你打开组件目录-里面有个分页组件-叫做page-btn-可是你完全不知道要怎么给新组件命名-因为即使新组件模块名与page-btn不一样-也不能保证新组件与分页组件不冲突。" class="header-anchor">#</a> 你面临的问题是：你打开组件目录，里面有个分页组件，叫做<code>page-btn</code>，可是你完全不知道要怎么给新组件命名，因为即使新组件模块名与<code>page-btn</code>不一样，也不能保证新组件与分页组件不冲突。</h6> <p>比如新的需求是“新增一个列表组件”，如果该组件的名字叫做<code>list</code>，其根节点的名字叫<code>list</code>，那么这个组件下面写的样式，就很可能和<code>.page-btn .list的</code>样式冲突:</p> <div class="language- extra-class"><pre class="language-text"><code>.list { /* ... */ }
</code></pre></div><p>这还仅仅只有两个组件而已，实际项目中，十几个或几十个组件，难道我们要每个组件都检查一下来“新组件名是否和以往组件的子元素命名冲突了”么？这不现实。</p> <p>BEM禁止使用子代选择器，以上是原因之一。子代选择器不好的地方还在于，如果层次关系过长，逻辑不清晰，非常不利于维护。为了懒得命名或者追求所谓的“精简代码”，写出下面这种选择器：</p> <div class="language- extra-class"><pre class="language-text"><code>.page-btn button:first-child {} 
.page-btn ul li a {} 
/* ... */ /* 维护代码，新增需求 */ 
.page-btn .prev {}
</code></pre></div><p>用层次关系结构关系来定位元素，可能会因为需求改变而大面积的重写样式文件。试想一下维护这类代码有多么痛苦，我们要一边检查该元素的上下文DOM结构，一边对照着css文件，一一对比，找到该元素对应的样式，也就是说我为了改一个元素的代码，需要不断翻阅HTML文件和CSS文件，可维护性非常之差。更有甚者，来维护这块代码的同事，直接在样式文件最后添加覆盖样式，这会造成一个非常严重的问题了：
<strong>同一个元素样式零散的分布在文件的不同地方，而且定位该元素的选择器也可能各不相同。</strong>
这样的样式文件只会越写越糟糕，可以说，当我们用子代选择器来定位元素时，这个样式文件就已经注定是要被翻来覆去的重构的了，甚至，每个来维护这个文件的人都会将其重构一遍。</p> <p>子代选择器还会造成权重过大的问题，当我们要做响应式的时候，某个带样式的元素需要适配不同的屏幕，此时，我们还要不断的确认该元素之前的选择器写法！为了覆盖前面权重过大的样式，甚至通过添加额外的类名或标签名来增加权重。可想而知，此后这个样式文件的维护难度就像雪球一样，越滚越大。</p> <p>如果我们用的是BEM，要覆盖样式很简单：找到要覆盖样式的元素，得知它的类名，在媒体查询中，用它的类名作为选择器，写下覆盖样式，样式就覆盖成功了，不需要担心前面样式的权重过大。</p> <h5 id="bem修饰器"><a href="#bem修饰器" class="header-anchor">#</a> BEM修饰器</h5> <p>根据不同的场景，组件可能会表现出不同的样式。比如分页组件在pc端具有具体的页码以及上下页按钮，但在移动端，因空间有限，可能只保留上下页按钮。我们可以用修饰器来区分这两种情况。默认情况下，分页按钮的类名为<code>page-btn</code>，但在移动端，我们需要加多个类名<code>page-btn--min</code></p> <div class="language- extra-class"><pre class="language-text"><code>/* 缩小版分页组件中，具体页码按钮隐去 */ .page-btn--min .page-btn__btn { display: none; } .page-btn--min .page-btn__prev { width: 50%; } .page-btn--min .page-btn__prev { width: 50%; } 
</code></pre></div><p>上面这种情况用了子代选择器，BEM是不允许这么写的，BEM中修饰器的样式不依赖于任何结构关系，也就是说，元素的状态改变只会影响自身，不对其他元素进行影响，但实际上，这很难做到的。以上的写法不会造成样式冲突的，而且权重的影响也不大。
BEM修饰器代表着元素的状态，但有时候元素的状态需要js来控制，此时遵循规范没有任何好处，比如激活状态，BEM推荐的写法是：</p> <div class="language- extra-class"><pre class="language-text"><code>.block__element { display: none; } .block__element--active { display: block; } 
</code></pre></div><p>当用js为该元素添加状态时，我们需要知道该元素的名字<code>block__element</code>，这样我们才能推导出它的激活状态为<code>block__element--active</code>，这是不合理的，因为很多时候我们无法得知元素的名称，所以这时候，我们应该统一js控制状态的类名格式，比如<code>is-active</code>、<code>js-active</code>等等，这些类名只用作标识，不予许有默认的公共样式：</p> <div class="language- extra-class"><pre class="language-text"><code>.block__element { display: none; } .block__element.is-active { display: block; }
</code></pre></div><h5 id="原子类和bem"><a href="#原子类和bem" class="header-anchor">#</a> 原子类和BEM</h5> <p>BEM可以不需要用到原子类，但是如果已经引入了类似Bootstrap的框架，也没必要强制避免使用原子类，比如<code>“pull-right”、&quot;ellipsis&quot;、“clearfix”</code>等等类，这些类非常实用，和BEM是可以互补的。</p> <p>在组件开发中其实不推荐使用原子类，因为这会降低组件的可复用性。可复用性的最理想状态就是组件不仅仅在不同的页面中表现一致，在跨项目的情况下，也能够运行良好。如果组件的样式因为依赖于某几个原子类就要依赖整个Bootstrap库，那么组件d 迁移负担就重很多了。
原子类更适合应用在实际页面中，这是因为页面变动大而且不可复用，假设在header中，我们用到了两个组件logo和user-panel（用户操作面板），两个组件分别置于header的左侧和右侧，我们可以这么写：</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;div class=&quot;header clearfix&quot;]]&gt; &amp;lt;div class=&quot;logo pull-left&quot;]]&gt;&amp;lt;!-- ... --&amp;gt;&amp;lt;/div]]&gt; &amp;lt;div class=&quot;user-panel pull-left&quot;]]&gt;&amp;lt;!-- ... --&amp;gt;&amp;lt;/div]]&gt; &amp;lt;/div]]&gt; 
</code></pre></div><p>header可以封装成一个模块，但它复用程度不高，不能算是组件，所以即使使用原子类也没有关系。在项目中，使用原子类之前应该考虑一下，这个场景是否变动大而且不可复用，如果是的话，我们可以放心的使用原子类。
组件应该是“自洽的”，其本身就应该构成了一个“生态圈”，也就是说，他几乎不需要外部供给，自给自足就能够运转下去。</p> <h5 id="实际页面中也应该使用bem"><a href="#实际页面中也应该使用bem" class="header-anchor">#</a> 实际页面中也应该使用BEM</h5> <p>在实际页面中也需要用到BEM命名方法，不然乱起的一个名字很可能就和某一组件冲突了，导致样式相互覆盖。
假如我们有联系页面，路径是<code>/pages/contact/</code>。那么该页面的模块名可以是<code>page-contact</code>，其名下元素均以<code>page-contact__element-name</code>命名。</p> <p>一般来说，实际页面中只是对组件进行调用，对组件的位置进行调整，但不会对组件内部细节进行修改。但实际情况下，同一个组件在不同页面不同模样的情况也是有的，所以会出现在实际页面中对组件样式进行微调的代码：</p> <div class="language-/* 联系页面对分页按钮进行微调 */ .page-contact .page-btn {} extra-class"><pre class="language-text"><code></code></pre></div><p>但更推荐的做法是给分页组件添加一个修饰器，将上面的样式放到修饰器名下，再根据实际情况运用到页面中。
<code>webpack css-loader</code> 解决之道</p> <p>BEM主要被诟病的一点在于其命名过长，结合Angular这种带有标签指令的框架时，整个HTML看起来会更混乱：</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;!-- 发帖页面 --&amp;gt; &amp;lt;span ng-repeat=&quot;post in postData track by post.id&quot; ng-if=&quot;$index === 0&quot; class=&quot;page-post__post-item&quot; ng-class=&quot;{'page-post__post-item--even': $even}&quot; popover-content=&quot;&quot;]]&gt; &amp;lt;/span]]&gt; 
</code></pre></div><p>当然，我们可以通过换行来缓解这个问题:</p> <div class="language- extra-class"><pre class="language-text"><code>&amp;lt;!-- 发帖页面 --&amp;gt; &amp;lt;span ng-repeat=&quot;post in postData track by post.id&quot; ng-if=&quot;$index === 0&quot; class=&quot;page-post__post-item&quot; ng-class=&quot;{'page-post__post-item--even': $even}&quot; popover-content=&quot;&quot;]]&gt; &amp;lt;/span]]&gt; 
</code></pre></div><p>但其实说穿了，BEM保证样式不冲突的核心就是：在元素名中加入唯一的标识。这个标识在BEM中对应的是模块名，也可能是一个独一无二的乱序字符串。
为模块中每个元素名加入标识，这可是重复的工作啊，重复的工作就应该交给机器去做。</p> <p>webpack加载器css-loader，可在js中读取css样式，自2015年4月份起，该插件加入了placeholder功能，使得该插件可以解决CSS作用域的问题，原理也就是给元素的名称加入唯一的标识。</p> <div class="language- extra-class"><pre class="language-text"><code>/* 分页组件 */ :local(.prev) {} css-loader
</code></pre></div><p>加载器自定义的语法：<code>:local(.identifier){}</code>向外暴露出选择器<code>.prev</code>。在JS代码中，我们可以拿到这个选择器：</p> <div class="language- extra-class"><pre class="language-text"><code>import styles from './page-btn.css'; var $prevBtn = $('&amp;lt;button class=&quot;' + styles.prev + '&quot;&amp;gt;上一页&amp;lt;/button&amp;gt;'); // ... styles.prev
</code></pre></div><p>返回的是一串独一无二且随机的字符串，该字符串对应着样式文件中的选择器。这名字有悖语义化，但css-loader支持配置字符串的生成格式，</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/2020/09/14.html" class="prev">
        14、js常用数组的方法总结
      </a></span> <span class="next"><a href="/2020/09/16.html">
        16、javascript 中的 call 和 apply 实现原理
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.617b9cc5.js" defer></script><script src="/assets/js/2.e6a2dc2d.js" defer></script><script src="/assets/js/7.9fa2cd7c.js" defer></script>
  </body>
</html>
