(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{380:function(t,s,a){"use strict";a.r(s);var e=a(42),o=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"koa-jsonp-demo"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#koa-jsonp-demo"}},[t._v("#")]),t._v(" koa-jsonp-demo")]),t._v(" "),a("p",[t._v("通过koa实现jsonp的接口提供前端使用。")]),t._v(" "),a("blockquote",[a("p",[t._v("项目地址：https://github.com/dai1254473705/koa-jsonp-demo")])]),t._v(" "),a("h2",{attrs:{id:"项目说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#项目说明"}},[t._v("#")]),t._v(" 项目说明")]),t._v(" "),a("ul",[a("li",[t._v("启动："),a("code",[t._v("npm run start")])])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("|--routes/\n|  |--api.js        接口路由\n|  |--pages.js      页面路由\n|\n|--static/\n|  |--javascript/\n|  |   |--axios.js\n|  |   |--index.js  调用接口的js\n|  |--styles/\n|      |--index.css\n|\n|--views/\n|  |--index.ejs    ejs模板\n|\n|--app.js          入口文件\n|--package.json\n|--README.md\n")])])]),a("h3",{attrs:{id:"一、-什么是同源策略"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、-什么是同源策略"}},[t._v("#")]),t._v(" 一、 什么是同源策略？")]),t._v(" "),a("h5",{attrs:{id:"_1-同源策略是一个重要的安全策略-它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档-减少可能被攻击的媒介。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-同源策略是一个重要的安全策略-它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档-减少可能被攻击的媒介。"}},[t._v("#")]),t._v(" 1. 同源策略是一个重要的安全策略，它用于限制一个origin的文档或者它加载的脚本如何能与另一个源的资源进行交互。它能帮助阻隔恶意文档，减少可能被攻击的媒介。")]),t._v(" "),a("h4",{attrs:{id:"_2-同源的定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-同源的定义"}},[t._v("#")]),t._v(" 2. 同源的定义")]),t._v(" "),a("blockquote",[a("p",[t._v("如果两个 URL 的 protocol、port (如果有指定的话)和 host 都相同的话，则这两个 URL 是同源。这个方案也被称为“协议/主机/端口元组”，或者直接是 “元组”。（“元组” 是指一组项目构成的整体，双重/三重/四重/五重/等的通用形式）。")])]),t._v(" "),a("p",[t._v("下表给出了与 URL http://store.company.com/dir/page.html 的源进行对比的示例:")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("URL")]),t._v(" "),a("th",[t._v("结果")]),t._v(" "),a("th",[t._v("原因")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("http://store.company.com/dir2/other.html")]),t._v(" "),a("td",[t._v("同源")]),t._v(" "),a("td",[t._v("只有路径不同")])]),t._v(" "),a("tr",[a("td",[t._v("http://store.company.com/dir/inner/another.html")]),t._v(" "),a("td",[t._v("同源")]),t._v(" "),a("td",[t._v("只有路径不同")])]),t._v(" "),a("tr",[a("td",[t._v("https://store.company.com/secure.html")]),t._v(" "),a("td",[t._v("失败")]),t._v(" "),a("td",[t._v("协议不同")])]),t._v(" "),a("tr",[a("td",[t._v("http://store.company.com:81/dir/etc.html")]),t._v(" "),a("td",[t._v("失败")]),t._v(" "),a("td",[t._v("端口不同 ( http:// 默认端口是80)")])]),t._v(" "),a("tr",[a("td",[t._v("http://news.company.com/dir/other.html")]),t._v(" "),a("td",[t._v("失败")]),t._v(" "),a("td",[t._v("主机不同")])])])]),t._v(" "),a("h4",{attrs:{id:"二、常用的跨域解决方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、常用的跨域解决方式"}},[t._v("#")]),t._v(" 二、常用的跨域解决方式？")]),t._v(" "),a("blockquote",[a("p",[t._v("以下几种方法是我平时工作中常用到的，cors和nginx前端是无感知的；但是如果是nodejs做中间件处理，跨域就不需要后端人员参与了；而jsonp的方式就需要前后端进行配合，后端需要对jsonp进行支持，前端需要使用特殊的请求接口的方法。")])]),t._v(" "),a("ol",[a("li",[t._v("由后端开发人员设置cors；")]),t._v(" "),a("li",[t._v("运维人员通过nginx代理；")]),t._v(" "),a("li",[t._v("通过nodejs作为中间件；")]),t._v(" "),a("li",[t._v("前后端配合，使用jsonp跨域；")])]),t._v(" "),a("h3",{attrs:{id:"二、jsonp的实现模式-callback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、jsonp的实现模式-callback"}},[t._v("#")]),t._v(" 二、JSONP的实现模式--CallBack")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("jsonp的机制是，我们传给服务器一个callback参数，值是我们要调用的函数名字，然后服务器返回一个字符串，这个字符串不仅仅是需要返回的数据，而且这个数据要用这个函数名字包裹。")])]),t._v(" "),a("li",[a("p",[t._v("解析请求所带的参数，并且读取callback参数的值。解决方法是，我们用ctx.request.query获得请求所带的所有参数，然后读取出callback参数：ctx.request.query.callback。")])]),t._v(" "),a("li",[a("p",[t._v("把数据转化为字符串，并用这个函数名包裹。")])])]),t._v(" "),a("h5",{attrs:{id:"前端js实现jsonp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前端js实现jsonp"}},[t._v("#")]),t._v(" 前端js实现jsonp")]),t._v(" "),a("blockquote",[a("p",[t._v("见"),a("code",[t._v("static/javascript/index.js")])])]),t._v(" "),a("ul",[a("li",[t._v("因为script、img、link是可以跨域加载资源的，没有被通源策略所限制，因此jsonp实际就是通过这一类标签加载资源的时候发出get请求()，同时将回调函数添加到url上面(如：?callback=jsonpmethod)，后端接收到对其单独处理，将返回数据放到"),a("code",[t._v("jsonpmethod")]),t._v("中返回。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(' jsonpData: function () {\n    const script = document.createElement("script");\n    script.setAttribute("type", "text/javascript");\n    script.src = "/api/userjsonp?callback=jsonpmethod";\n    document.body.appendChild(script);\n  },\n')])])]),a("h5",{attrs:{id:"node端实现jsonp支持"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#node端实现jsonp支持"}},[t._v("#")]),t._v(" node端实现jsonp支持")]),t._v(" "),a("blockquote",[a("p",[t._v("代码见 "),a("code",[t._v("routes/api.js")]),t._v("，其中包含了get、post、jsonp三种方法的对比；")])]),t._v(" "),a("ul",[a("li",[t._v("get和post方法直接通过穿ctx.body返回一个json就可以")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ctx.body = {\n    code:200,\n    data,\n    msg:'success'\n};\n")])])]),a("ul",[a("li",[t._v("jsonp的需要对返回值做处理，如果请求URL为***?callback=jsonpmethod,返回为"),a("code",[t._v("jsonpmethod(json字符串)")]),t._v("的格式")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const result = JSON.stringify({\n    code:200,\n    data,\n    msg:'success'\n});\nctx.body = `jsonpmethod(${result})`;\n")])])])])}),[],!1,null,null,null);s.default=o.exports}}]);