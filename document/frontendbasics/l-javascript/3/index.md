# 3. 正则基础

## 1. `RegExp` 构造函数

正则表达式就是一种描述字符串结构模式的形式化表达式。

**参数是字符串:**
```js
const regex = new RegExp('xyz', 'i');
// 等价于
const regex = /xyz/i;
```
**参数是一个正则表示式:**

```js
const regex = new RegExp(/xyz/i);
// 等价于
const regex = /xyz/i;
```
如果第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式`会忽略`原有的`正则表达式的修饰符`，只使用新指定的修饰符。

```js
new RegExp(/abc/ig, 'i').flags
// "i",忽略了g
```

### 1.1 正则表达式构造函数new RegExp(“xxx”)与正则表达字面量/xxx/有什么不同？

- 当使用`RegExp()`构造函数的时候，不仅需要转义引号（即`\`表示），并且还需要`双反斜杠`（即`\\`表示一个`\`）。
- 使用正则表达字面量的效率更高。

## 2. 元字符

| 元字符 | 对应说明 |
| --- | --- |
| `.` | 匹配除换行符之外的任意字符 |
| `\w` | 匹配字母数字下划线，等同于：[a-zA-Z0-9_] |
| `\s` | 匹配任意空白符 |
| `\d` | 匹配数字，等同于[0-9] |
| `\b` |  匹配单词边界 |
| `|` | 或匹配，如 /x\|y/ 正则可匹配x或y两个字符 |
| `^` | 匹配字符串的开始 |
| `$` |匹配字符串的结束 |

## 3. 反义字符
|反义字符 | 对应说明|
|--- | ---|
|`[^x]` | 匹配除“x”之外的所有字符，其中“x”可以为任意字符|
|`[^xyz]` | 同上，匹配除“x、y、z”之外的任意字符|
|`\W` | 匹配除了字母、数字、下划线之外的所有字符，等同于：[^\w]|
|`\S` | 匹配除空白符之外的任意字符，等同于：[^\s]|
|`\B` | 匹配不是单词边界的字符，等同于：[^\b]|
|`\D` | 匹配不是数字的所有字符，等同于：[^\d]|

## 4. 重复匹配
|匹配字符 | 对应说明|
|--- | ---|
|`*` | 重复出现零次或多次|
|`+` | 重复出现一次或多次|
|`?` | 重复出现零次或一次|
|`{n}` | 重复出现n次|
|`{n,}` | 至少重复出现n次|
|`{m,n}` | 重复重现m到n次，其中，m<n|

## 5. 分组/捕获
|分组字符 | 对应说明|
|--- | ---|
|`(exp)` | 用小圆括号进行分组，每一个分组匹配的结果使用 $n 接收, 每一个分组都是一个匹配规则互不影响|
|`(?:exp)` | 匹配exp正则，但不产生分组号|
|`exp1(?=exp2)` | 前瞻断言，匹配exp1，但后面必须是exp2,如匹配名字叫xianlie，但不姓zhao的人：/zhao(?=xianlie)/  请注意：前瞻断言只是一个测试，括号 (?=…) 中的内容不包含在匹配结果中|
|`exp1(?!=exp2)` | 后瞻断言，匹配exp1，但后面不能是exp2,如匹配姓zhao，但名字不叫xianlie的人：/zhao(?!xianlie)/|

### 5.1 前瞻断言/先行断言（lookahead）

```js
input:
'zhaoxiaohong'.match(/zhao(?=xiaohong)/)
output:
['zhao', index: 0, input: 'zhaoxiaohong', groups: undefined]
```

```js
input:
'zhaoxaohong'.match(/zhao(?=xiaohong)/)
output:
null
```

### 5.2 贪婪与惰性
|相关字符 | 对应说明|
|--- | ---|
|`*?` | 重复任意次，但尽可能少的重复|
|`+?` | 重复一次或多次，但尽可能少的重复|
|`??` | 重复零次或一次，但尽可能少的重复|
|`{m,n}?` | 重复m到n次，但尽可能少的重复|
|`{n,}?` | 重复n次以上，但尽可能少的重复|
|`{n}?` | 重复n次，但尽可能少的重复|

### 5.3 修饰符
|修饰符 | 对应说明|
|--- | ---|
|`i` | ignore - 不区分大小写，将匹配设置为不区分大小写，搜索时不区分大小写: `A` 和 `a` 没有区别。|
|`g` | gglobal - 全局匹配，查找所有的匹配项。|
|m|multi line - 多行匹配,使边界字符 `^` 和 `$` 匹配每一行的开头和结尾，记住是多行，而不是整个字符串的开头和结尾。|
|s|特殊字符圆点 `.` 中包含换行符 `\n`。默认情况下的圆点 `.` 是匹配除换行符 `\n` 之外的任何字符，加上 `s` 修饰符之后, `.` 中包含换行符 `\n`。|
|`u`|含义为“Unicode模式”，用来正确处理大于`\uFFFF`的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。|
|`y`|**粘连**（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。|


## 6. flags和source属性

+ `source`返回正则表达式的正文
```js
/abc/ig.source
// "abc"
```

+ `flags`返回正则表达式的修饰符
```js
/abc/ig.flags
// 'gi'
```
## 7. 字符串的正则方法

字符串对象共有4个方法，可以使用正则表达式：`match()`、`replace()`、`search()`和`split()`。

ES6将这4个方法，在`语言内部全部调用RegExp的实例方法`，从而做到所有与正则相关的方法，全都定义在`RegExp`对象上。

+ **String.prototype.match**:
```js
RegExp.prototype[Symbol.match]
```
+ **String.prototype.replace** 
```js
RegExp.prototype[Symbol.replace]
```
+ **String.prototype.search**
```js
RegExp.prototype[Symbol.search]
```
+ **String.prototype.split**
```js
RegExp.prototype[Symbol.split]
```
