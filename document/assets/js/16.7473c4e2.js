(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{367:function(t,n,e){"use strict";e.r(n);var s=e(42),a=Object(s.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"_23、一文搞懂this指向问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23、一文搞懂this指向问题"}},[t._v("#")]),t._v(" 23、一文搞懂this指向问题")]),t._v(" "),e("h4",{attrs:{id:"_1-事件调用环境"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-事件调用环境"}},[t._v("#")]),t._v(" 1. 事件调用环境")]),t._v(" "),e("blockquote",[e("p",[t._v("谁触发的this指向谁")])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <title>Document</title>\n    <style>\n        .box{\n            width: 100px;\n            height: 100px;\n            background: #999;\n            margin: 10px;\n        }\n    </style>\n</head>\n<body>\n    <div class="box box1">box1</div>\n    <div class="box box2">box2</div>\n</body>\n<script>\n    const box1 = document.querySelector(\'.box1\');\n    const box2 = document.querySelector(\'.box2\');\n\n    box1.onclick = clickBox;\n    box2.onclick = clickBox;\n\n    function clickBox (){\n        console.log(this);\n    };\n<\/script>\n</html>\n')])])]),e("p",[t._v("如上代码，分别给box1,box2绑定了clickBox方法，如果点击的是box1，则clickBox中的this就会指向当前点击的box1元素。")]),t._v(" "),e("img",{attrs:{src:t.$withBase("/20200923/001.jpg"),alt:"foo"}}),t._v(" "),e("h5",{attrs:{id:"_2-函数内部this指向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-函数内部this指向"}},[t._v("#")]),t._v(" 2.函数内部this指向")]),t._v(" "),e("h6",{attrs:{id:"_1-非严格模式下直接调用test时-this指向的是window"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-非严格模式下直接调用test时-this指向的是window"}},[t._v("#")]),t._v(" (1)非严格模式下直接调用test时，this指向的是window")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function test(){\n    console.log(this); // window\n};\ntest();\n")])])]),e("h6",{attrs:{id:"_2-严格模式下直接调用test时-this指向的是undefined"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-严格模式下直接调用test时-this指向的是undefined"}},[t._v("#")]),t._v(" (2)严格模式下直接调用test时，this指向的是undefined")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("'use strict';\nfunction test(){\n    console.log(this); // undefined\n};\ntest();\n")])])]),e("h6",{attrs:{id:"_3-对象中的this指向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-对象中的this指向"}},[t._v("#")]),t._v(" (3)对象中的this指向")]),t._v(" "),e("blockquote",[e("p",[t._v("this最终指向的是调用它的对象\n函数呗多层对象所包含，如果函数被最外层对象调用，this指向的是它上一级的对象。")])]),t._v(" "),e("p",[t._v("b是obj对象上的一个方法，通过obj.b或者window.obj.b执行时，是b方法是b的上一级obj调用的，this指向obj;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n    a:'11',\n    b:function(){\n        console.log(this);//obj\n    }\n};\nobj.b();\nwindow.obj.b();\n")])])]),e("p",[t._v("同理，调用fn的时候，fn是由上一级b调用的，所以this指向的是b。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n    a:'11',\n    b:{\n        fn:function(){\n            console.log(this);// b\n        }\n    }\n};\nobj.b.fn();\n")])])]),e("p",[t._v("将obj.b.fn方法复制给变量abc,此时fn方法并没有执行，而是将fn赋值给abc,此时abc也就是一个function了，当执行abc时，实际是window.abc，则此时this指向的上一级就是window。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n    a:'11',\n    b:{\n        fn:function(){\n            console.log(this);//window\n        }\n    }\n};\nlet abc = obj.b.fn;\nconsole.log(typeof abc);//function\nabc();\n")])])]),e("h5",{attrs:{id:"_3-构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-构造函数"}},[t._v("#")]),t._v(" 3.构造函数")]),t._v(" "),e("p",[t._v("构造函数需要使用"),e("code",[t._v("new")]),t._v("关键字，"),e("code",[t._v("new")]),t._v("关键字使用时会有以下几步：")]),t._v(" "),e("ul",[e("li",[t._v("1.调用函数")]),t._v(" "),e("li",[t._v("2.自动创建一个空对象")]),t._v(" "),e("li",[t._v("3.把创建出来的对象和this进行绑定")]),t._v(" "),e("li",[t._v("4.如果构造函数（Fn）没有返回值，隐式返回this对象，如果(Fn)有返回值（如：return {d:'d'}）,则返回构造函数中的返回值。")])]),t._v(" "),e("p",[t._v("判断this指向(没有返回值)")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Fn (){\n    this.num = 1;\n}\nFn.num = 2;\nFn.prototype.num = 3;\nFn.prototype.method = function(){\n    console.log(this);\n};\n")])])]),e("p",[t._v("此时实例化Fn,newFn就是Fn构造函数，调用newFn.method时，method就指向了Fn，因为Fn内部没有"),e("code",[t._v("this.method")]),t._v("方法，所以会查找prototype上的method,此时method方法中的this指向的是Fn构造函数；")]),t._v(" "),e("p",[t._v("newFn.num执行时，发现构造函数内有"),e("code",[t._v("this.num")]),t._v("，则输出的是1，如果"),e("code",[t._v("this.num=1")]),t._v("不存在的话，则会调用"),e("code",[t._v("prototype.num")]),t._v("，那个时候"),e("code",[t._v("newFn.num")]),t._v("就会是3了。")]),t._v(" "),e("p",[t._v("而直接调用Fn.num就会查找的是Fn构造函数上的num，\n即：Fn.num")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var newFn = new Fn();\nnewFn.method();\nconsole.log(newFn.num);\nconsole.log(Fn.num);// 2\n")])])]),e("p",[t._v("下面定义prototype为Fn.prototype，则调用method方法时，实际就是调用的prototype上的method,此时method的上一级是Fn的prototype，所以this指向的是Fn.prototype，如果method中输出this.num，则此时num指向的就是"),e("code",[t._v("Fn.prototype.num = 3;")]),t._v(",即method中的num是3;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var prototype = Fn.prototype;\nprototype.method();\n")])])]),e("p",[t._v("如果再次将prototype.method赋值给method变量，则执行method时，上一级实际为window，此时method中的this就是window对象了（非严格模式，严格模式为undefined）")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var method = prototype.method;\nmethod();\n")])])]),e("p",[t._v("判断this指向（有返回值）\n如果构造函数有返回值,并且返回值是对象、数组、函数、Date、RegExp等内置对象，此时在调用Fn上的相关方法指向的都是返回的对象，如下返回的"),e("code",[t._v("{dd:'11'}")]),t._v("对象")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("function Fn (){\n    this.num = 1;\n    return {\n        dd:'11'\n    }\n}\nFn.num = 2;\nFn.prototype.num = 3;\nFn.prototype.method = function(){\n    console.log(this);\n};\n")])])]),e("p",[t._v("此时newFn实际就是"),e("code",[t._v("{dd:'11'}")]),t._v("，执行"),e("code",[t._v("newFn.method")]),t._v("就会报错，因为此时newFn指向的是返回值，而不是Fn构造函数了，"),e("code",[t._v("{dd:'11'}")]),t._v(" 上并没有method方法。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var newFn = new Fn();\nnewFn.method();\n")])])]),e("h5",{attrs:{id:"_4-箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-箭头函数"}},[t._v("#")]),t._v(" 4.箭头函数")]),t._v(" "),e("blockquote",[e("p",[t._v("箭头函数本身没有this和arguments，在箭头函数中引用this实际调用的是定义的上一层作用域的this。(对象是没有作用域的)")])]),t._v(" "),e("p",[t._v("如下，在上文中我们知道对象中的方法执行时，this指向是指向调用它的上级的。在obj.c方法调用时是没有问题的，但是如果是箭头函数，则箭头函数中的this在定义箭头函数的时候就被指定到上一层作用域了，而对象没有作用域，因d方法中的this在非严格模式下就指向上层的window对象了。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("var obj = {\n    c:function(){\n        console.log(this);\n    },\n    d:()=>{\n        console.log(this);\n    }\n};\nobj.c();// obj\nobj.d();// window\n")])])]),e("h5",{attrs:{id:"_5-修改this指向"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-修改this指向"}},[t._v("#")]),t._v(" 5.修改this指向")]),t._v(" "),e("blockquote",[e("p",[t._v("可通过call,apply,bind实现")])])])}),[],!1,null,null,null);n.default=a.exports}}]);