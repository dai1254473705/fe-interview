(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{368:function(e,t,a){"use strict";a.r(t);var r=a(42),n=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_24、数据响应式原理剖析"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24、数据响应式原理剖析"}},[e._v("#")]),e._v(" 24、数据响应式原理剖析")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("proxy 代理与数据劫持")])]),e._v(" "),a("li",[a("p",[e._v("Handler.set()")])]),e._v(" "),a("li",[a("p",[e._v("Handler.get()")])]),e._v(" "),a("li",[a("p",[e._v("Handler...")])]),e._v(" "),a("li",[a("p",[e._v("vue中的数据响应式实现")]),e._v(" "),a("ul",[a("li",[e._v("获取子元素")]),e._v(" "),a("li",[e._v("匹配内容规划")]),e._v(" "),a("li",[e._v("修改视图")])])]),e._v(" "),a("li",[a("p",[e._v("vue中双向绑定实现")]),e._v(" "),a("ul",[a("li",[e._v("监控数据变化")]),e._v(" "),a("li",[e._v("通过自定义事件通知")]),e._v(" "),a("li",[e._v("修改视图")])])])]),e._v(" "),a("h4",{attrs:{id:"proxy语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proxy语法"}},[e._v("#")]),e._v(" proxy语法")]),e._v(" "),a("p",[e._v("Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）")]),e._v(" "),a("blockquote",[a("p",[e._v("const p = new Proxy(target, handler)")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("target\n要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。")])]),e._v(" "),a("li",[a("p",[e._v("handler\n一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。")])])]),e._v(" "),a("p",[a("code",[e._v("常用方法")])]),e._v(" "),a("blockquote",[a("p",[e._v("handler.get()\n属性读取操作的捕捉器。")])]),e._v(" "),a("blockquote",[a("p",[e._v("handler.set()\n属性设置操作的捕捉器。")])]),e._v(" "),a("ul",[a("li",[e._v("set()方法用来拦截某个属性的赋值操作，可以接受4个参数，依次为目标对象，属性名，属性值，Proxy对象本身,最后一个参数可选。")])]),e._v(" "),a("p",[e._v("下面代码通过proxy代理了data对象")]),e._v(" "),a("ul",[a("li",[e._v("set方法中target代表的是代理的对象，即data；prop是当前修改的data中的属性，如下为b属性；newValue为修改b属性时的值；\n当修改p.b时，set方法就会执行，需要在set方法中修改target的值；\nset 中需要return true；表示设置成功")])]),e._v(" "),a("p",[e._v("通过Reflect.set(p,'c',3)设置p中的属性时，如果成功则返回true(set方法中的返回值)")]),e._v(" "),a("ul",[a("li",[e._v("get 方法在p中的属性被调用时触发；需要有返回值")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var data = {\n    a:1,\n    b:2\n};\nlet p = new Proxy(data,{\n    set(target,prop,newValue){\n        console.log(target,prop,newValue);\n        target[prop] = newValue;\n        return true;\n    },\n    get(target,prop){\n        console.log(target,prop);\n        return target[prop];\n    }\n});\np.b = 3;\n")])])]),a("p",[a("code",[e._v("和reflect配合使用")])]),e._v(" "),a("ul",[a("li",[e._v("Reflect为操作对象而提供的新API")]),e._v(" "),a("li",[e._v("将Object对象的属于语言内部的方法放到Reflect对象上，即从Reflect对象上拿Object对象内部方法。")])]),e._v(" "),a("p",[e._v("+将用 老Object方法 报错的情况，改为返回false")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("try {\n  Object.defineProperty(target, property, attributes);\n  // success\n} catch (e) {\n  // failure\n}\n")])])]),a("p",[e._v("可以写为")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("if (Reflect.defineProperty(target, property, attributes)) {\n  // success\n} else {\n  // failure\n}\n")])])]),a("ul",[a("li",[e._v("让Object操作变成函数行为\n老写法（命令式写法）\n"),a("code",[e._v("'name' in Object //true")]),e._v("\n新写法\n"),a("code",[e._v("Reflect.has(Object,'name') //true")])])]),e._v(" "),a("p",[e._v("Reflect和proxy方向相同,可以直接将arguments传入set或者get")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("var data = {\n    a:1,\n    b:2\n};\nlet p = new Proxy(data,{\n    set(target,prop,newValue){\n        console.log(target,prop,newValue);\n        // 表示成功\n        return Reflect.set(...arguments);\n    },\n    get(target,prop){\n        console.log(target,prop);\n        return Reflect.get(...arguments);\n    }\n});\np.c = 3\nconsole.log(p.c);\n")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);